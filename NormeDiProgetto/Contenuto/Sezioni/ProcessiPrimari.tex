\section{Processi Primari}
\subsection{Fornitura}
\subsubsection{Scopo}
Lo scopo del processo\textsuperscript{G} di fornitura, come definito nello standard ISO/IEC/IEEE 12207:1995, è di determinare quali strumenti, risorse e competenze siano necessarie per lo svolgimento del progetto. 

\subsubsection{Descrizione}
La presente sezione contiene tutte le norme che ogni membro del gruppo è tenuto a seguire, durante le varie fasi di svolgimento del progetto, per poter divenire fornitori\textsuperscript{G} del proponente\textsuperscript{G} \zd e dei committenti\textsuperscript{G} Prof. Tullio Vardanega e Prof. Riccardo Cardin. 
Verrà definita la gestione dei rapporti con il proponente, comprese consegna e manutenzione del prodotto finale.

\subsubsection{Rapporti con il proponente}
Il gruppo entrerà in contatto con il proponente \zd per:
\begin{itemize}
	\item Approfondire aspetti chiave con il proponente per far fronte ai sui bisogni; 
	\item Chiarire ogni eventuale dubbio emerso;
	\item Stimare tempistiche di lavoro;
	\item Individuare le strategie lavorative più efficaci;
	\item Definizione dei requisiti e vincoli da rispettare;
	\item Proporre nuove soluzioni o alternative, discutendo di vantaggi, svantaggi e fattibilità.
\end{itemize}
A meno di accordi diversi con il proponente non sarà prevista nessuna manutenzione futura del prodotto dopo l'avvenuta consegna e collaudo.

\subsubsection{Materiale fornito}
Il materiale che il gruppo fornirà al proponente e ai committenti sono:
\begin{itemize}
  \item \textbf{\AdR} contiene l’analisi dei casi d’uso e dei requisiti con lo scopo di: 
	\begin{itemize}
		\item Determinare tutte e sole le funzionalità che saranno offerte dal prodotto finale;
		\item Chiarire ogni ambiguità che potrebbe sorgere nella comprensione del capitolato.
	\end{itemize}  

  \item \textbf{\PdP} contiene la pianificazione preventiva dei tempi, l’analisi dei rischi, il consuntivo di periodo, la data di consegna e i costi previsti;

  \item \textbf{\PdQ} contiene le modalità adottate in verifica e validazione, assicurando che la qualità dei processi e dei prodotti rispetti le aspettative.
  
  \item \textit{\textbf{Proof of Concept}} piccolo software di esempio che servirà al gruppo per determinare la fattibilità pratica e dimostrare la fondatezza e applicabilità di concetti fondamentali e costituenti in relazione al prodotto finale. 

\end{itemize}

Verrà allegata una \textbf{Lettera di Presentazione} alla documentazione. Lo scopo è quello di formalizzare l'impegno del gruppo nel portare a termine il prodotto software entro una scadenza specifica (definita nella lettera stessa) nel rispetto dei requisiti minimi del capitolato di riferimento. Nella stessa lettera saranno presenti le coordinate necessarie per l'accesso alla documentazione fornita.

\subsubsection{Preparazione al collaudo del prodotto}
Verranno instaurati rapporti più frequenti con l'azienda proponente in preparazione alla fase di collaudo.
Per poter avere esito positivo in fase di collaudo, il prodotto finito deve essere stato preventivamente preparato attraverso una campagna di test. In particolare:
\begin{itemize}
\item test d’unità;
\item test di regressione;
\item test d’integrazione;
\item test di sistema.
\end{itemize}

Dopo il superamento  dei test, il gruppo avrà la ragionevole garanzia di aver realizzato un prodotto corretto e completo.

Durante il collaudo va dimostrato al committente che:
\begin{itemize}
\item i test presenti nel \PdQ sono stati eseguiti e hanno ottenuto un esito conforme alle metriche dichiarate;
\item sono stati implementati al meglio i requisiti obbligatori definiti nell' \AdR ;
\item i requisiti desiderabili e facoltativi, nel caso fossero stati implementati, vanno oltre
alle aspettative minime del proponente.
\end{itemize}

\subsubsection{Collaudo e consegna}

Il gruppo \textit{DreamTeam} consegnerà all’azienda proponente e ai committenti:
\begin{itemize}
\item Il codice sorgente;
\item Documentazione di prodotto;
\item Glossario v3.0.0;
\item Manuale Utente v1.0.0;
\item Documentazione delle API v1.0.0;
\end{itemize}
\subsection{Sviluppo}

\subsubsection{Scopo}
Lo scopo del processo di sviluppo, secondo lo standard  ISO/IEC/IEEE 12207:1995 è definire compiti e attività da eseguire per realizzare il prodotto finale richiesto dal proponente.

\subsubsection{Descrizione}
Sono elencate e dopo trattate le seguenti attività di questo processo:
\begin{itemize}
  \item Analisi dei requisiti;
  \item Progettazione;
  \item Codifica.
\end{itemize}
\subsubsection{Analisi dei requisiti}
\paragraph{Scopo}
È compito di ogni \textit{Analista} scrivere il documento di \textit{Analisi dei Requisiti}. Lo scopo di tale documento è:
\begin{itemize}
  \item aiutare i \textit{Progettisti};
  \item stabilire ciò che si è concordato con il cliente;
  \item fornire una base per chiunque prenda sottomano il prodotto per miglioramenti;
  \item aiutare le revisioni del codice;
  \item fornire riferimenti utili ai \textit{Verificatori};
  \item tracciare il lavoro per stimarne i costi.
\end{itemize}

\paragraph{Descrizione}
L’obiettivo è la realizzazione dell’architettura del sistema.

\paragraph{Struttura}
La struttura potrà essere soggetta a cambiamenti. Attualmente, \AdR  presenta questa struttura:
\begin{itemize}
  \item Introduzione al documento;
  \item Descrizione generale, dove sono presenti requisiti estrapolati sia dal capitolato d’appalto che dagli incontri effettuati con il proponente (verbali esterni);
  \item Casi d'uso relativi alle varie funzionalità fruibili nella piattaforma\textsuperscript{G};
  \item Requisiti che dovrà soddisfare la piattaforma.
\end{itemize}

\paragraph{Classificazione casi d'uso}
La struttura adottata per la classificazione dei casi d'uso è la seguente: \\
\centerline{\textbf{UC[Identificatore][CodiceCasoBase](.[CodiceSottoCaso])*}}
Composta da:
\begin{itemize}
\item \textbf{UC}: acronimo di "Use Case";
\item \textbf{Identificatore}: che può assumere le diverse espressioni letterali:
	\begin{itemize}
		\item \textbf{W}: identifica un caso d'uso relativo alla WebApp;
		\item \textbf{E}: identifica un caso d'uso d'errore.
	\end{itemize}
\item \textbf{CodiceCasoBase}: ID del caso d'uso generico;
\item \textbf{CodiceSottoCaso}: ID opzionale per i sottocasi di un caso d'uso.
\end{itemize}

Ogni caso d'uso è descritto da: 
\begin{itemize}
    \item \textbf{Id}: codice identificativo del caso d'uso, stabilito come enunciato sopra;
    \item \textbf{Nome}: stringa titolo del caso d'uso posta dopo l'id;
    \item \textbf{Diagramma UML}: diagramma per rappresentare graficamente il caso d'uso;
    \item \textbf{Descrizione}: breve descrizione del caso d'uso;
    \item \textbf{Attori}: entità esterne al sistema che interagiscono con esso. Ne esistono due varianti: 
    \begin{itemize}
    \item \textbf{Primario}: interagisce con il sistema per raggiungere un obiettivo;
    \item \textbf{Secondario}: aiuta il primario a raggiungere l'obiettivo. Non utilizzato.
    \end{itemize}
    \item \textbf{Precondizione}: descrive lo stato del sistema prima del verificarsi del caso d'uso;
    \item \textbf{Postcondizione}: descrive lo stato del sistema dopo che si è verificato il caso d'uso;
    \item \textbf{Scenario principale}: elenco numerato che descrive il flusso degli eventi del caso d'uso;
    \item \textbf{Scenario secondario/alternativo}: elenco numerato che descrive il flusso degli eventi del caso d'uso dopo un evento imprevisto che lo ha deviato dal caso principale. Può non esserci o possono esserci più di uno;
    \item \textbf{Estensioni}: utilizzate negli scenari alternativi. Se si verifica una determinata situazione, il caso d'uso collegato all'estensione viene interrotto.
\end{itemize}

\paragraph{Modello di Diagramma di un Caso D'Uso}

Qui di seguito viene mostrato un esempio di diagramma di un caso d'uso con tutte le componenti UML usate.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{Contenuto/Immagini/UseCase.png}
\caption{Esempio di Caso D'Uso}
\end{figure}

\paragraph{Classificazione requisiti}

Un requisito è un obiettivo, accordato con il proponente o preso mediante una decisione interna, da raggiungere per risolvere un determinato problema. Per rappresentare un requisito, è stato scelto di adottare la seguente convenzione:

\begin{center}
\textbf{R[Importanza][Tipologia][Codice]}
\end{center}

dove:

\begin{itemize}
\item \textbf{Importanza}: rappresenta l'importanza associata al requisito e può assumere uno dei seguenti valori:
\begin{itemize}
	
	\item \textbf{1}: Requisito \textit{Obbligatorio}, la sua soddisfazione dovrà necessariamente avvenire per garantire una buona funzionalità dell’intero sistema;
	\item \textbf{2}: Requisito \textit{Desiderabile}, la sua soddisfazione non vincola il buon funzionamento del sistema, tuttavia ne fornisce una maggior completezza;
	\item \textbf{3}: Requisito \textit{Facoltativo}, se soddisfatto rende il sistema più completo, ma ciò potrebbe comportare un dispendio di energie con un conseguente aumento dei costi preventivati.
\end{itemize}
\item \textbf{Tipologia}: si riferisce alla tipologia di requisito e può assumere uno dei seguenti valori letterali:
\begin{itemize}
	\item \textbf{V}: requisito di \textit{Vincolo}, descrive i vincoli offerti dal sistema;
	\item \textbf{F}: requisito \textit{Funzionale}, descrive servizi o funzioni offerti dal sistema;
	\item \textbf{P}: requisito \textit{Prestazionale}, descrive i vincoli sulle prestazioni da soddisfare, con il numero di informazioni da manipolare in un certo intervallo di tempo;
	\item \textbf{Q}: requisito di \textit{Qualità}, descrive i vincoli di qualità da realizzare.
\end{itemize}
\item \textbf{Codice}: identifica in maniera univoca il requisito in forma gerarchica padre/figlio.
Per esplicitare la forma gerarchica, il codice viene rappresentato come segue:
\begin{center}
\textbf{[Identificatore][CodiceBase](.[CodiceSottoCaso])}
\end{center}
dove: 
\begin{itemize}
	\item \textbf{Identificatore}: può essere presente o meno. Nel caso sia presente, può assumere una delle seguenti espressioni letterali:
		\begin{itemize}
			\item \textbf{W}: identifica un caso d'uso relativo alla WebApp;
			\item \textbf{E}: identifica un caso d'uso di un errore.
		\end{itemize}
	\item \textbf{CodiceBase}: fa riferimento al caso d’uso preso in esame e, in combinazione con la Tipologia, definisce un identificatore univoco per il requisito;
	\item \textbf{CodiceSottoCaso}: codice progressivo opzionale, che può includere più livelli, ed identifica un eventuale sottocaso.
\end{itemize}
\end{itemize}

Dopo aver classificato ciascun requisito con un codice, quest’ultimo non potrà più essere cambiato.
Inoltre, ciascun codice verrà accompagnato da una serie di informazioni aggiuntive, che meglio definiranno ciascun requisito, ossia:

\begin{itemize}
	\item \textbf{Descrizione}: breve descrizione completa relativa allo scopo del requisito;
	\item \textbf{Classificazione}: indica l’importanza del requisito e può assumere i valori \textit{Obbligatorio}, \textit{Desiderabile} e \textit{Facoltativo}. Sebbene questa informazione possa sembrare ridondante, ne facilita la lettura;
	\item \textbf{Fonti}: indica le fonti del requisito, ossia possono essere:
	\begin{itemize}
		\item all'interno del Capitolato d’Appalto;
		\item nei Verbali Interni;
		\item nei Verbali Esterni;
		\item nei Casi d’Uso presenti nel documento “\AdR”;
		\item una decisione presa internamente (quindi “Decisione Interna”).
	\end{itemize}	 
\end{itemize}

Ad esempio:\\
\definecolor{darkblue}{cmyk}{99, 99, 0, 71}

\begin{table}[!htbp]
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{ m{0.15\textwidth}<{\centering}  m{0.37\textwidth}<{\centering}  m{0.23\textwidth}<{\centering}  m{0.15\textwidth}<{\centering}}
    \rowcolor{darkblue}
    \textcolor{white}{\textbf{Requisito}} &\textcolor{white}{\textbf{Descrizione}}& \textcolor{white}{\textbf{Classificazione}} & \textcolor{white}{\textbf{Fonti}}\\ 

    \rowcolor{gray!25} R1FW1 & L’utente deve riuscire ad inserire i propri dati personali (nome, cognome, indirizzo e-mail e password) per effettuare la registrazione & Obbligatorio & UCW1 \\

\end{tabular}
\end{table}

\paragraph{Qualità dei requisiti}
Ciascun requisito deve essere:
\begin{itemize}
  \item Completo, ovvero dettagliato;
  \item Consistente, che non sia in contraddizione con altri requisiti;
  \item Necessario;
  \item Verificabile, ovvero che sia possibile controllare che il sistema lo realizzi;
  \item Tracciabile.
\end{itemize}

\paragraph{Metriche}
Le metriche utilizzate per la valutazione dell'attività di analisi dei requisiti sono:
\begin{itemize}
\item \textbf{MQP05 Percentuale requisiti obbligatori soddisfatti} \\
Indica la quantità percentuale dei requisiti obbligatori soddisfatti in rapporto al totale dei requisiti obbligatori.
La formula è:
\begin{itemize}
  \item[] \[RS = \frac{ROS}{TRO} * 100;\]
  \item RS = Percentuale requisiti obbligatori soddisfatti;
  \item ROS = Requisiti obbligatori soddisfatti;
  \item TRO = Totale requisiti 	obbligatori.
  \end{itemize}
\end{itemize}


\subsubsection{Progettazione}
\paragraph{Scopo}
Lo scopo della Progettazione è di determinare le caratteristiche che il prodotto deve avere per soddisfare i requisiti individuati dagli stakeholder\textsuperscript{G}. Il procedimento seguito è l'opposto rispetto a quello usato per l'\AdR. Vengono individuate le diverse parti, coerenti con i requisiti, che verranno poi raggruppate in vari sottoinsiemi fino ad arrivare ad un'unica soluzione finale. Restano da rispettare i vincoli di sostenibilità nell'utilizzo delle risorse, nel contenimento dei costi e nel rispetto degli obiettivi di qualità.

\paragraph{Descrizione}
L’obiettivo è la realizzazione dell’architettura del sistema.

\paragraph{Technology Baseline}
Misura la comprensione delle tecnologie individuate per la realizzazione del prodotto, motivandone la scelta. 
Dovranno essere mostrate:
\begin{itemize}
	\item Le varie tecnologie adottate, motivando le scelte;
	\item Le relazioni tra i vari componenti e come interagiscono tra di loro;
	\item Il \textit{\textbf{Proof of Concept}}: un prototipo (incompleto) eseguibile che riunisce tutte le tecnologie adottate, dimostrando in maniera pratica la loro adeguatezza e compatibilità reciproca. 
\end{itemize}

\paragraph{Product Baseline}
Rappresenta la baseline architetturale (design e coding) del prodotto, coerente con la Technology Baseline. Mostra il design definitivo del prodotto.
Dovrà contenere:
\begin{itemize}
	\item Diagrammi UML delle classi e di sequenza;
	\item Tracciamento per ogni classe dei requisiti che deve soddisfare;
	\item Descrizione dei design pattern utilizzati;
	\item Descrizione dell'architettura generale del prodotto software.
\end{itemize}

\paragraph{Qualità}
È compito del \textit{Progettista} definire un'architettura di qualità. Le caratteristiche che essa dovrà avere sono:

\begin{itemize}
  \item Soddisfare i requisiti indicati nel documento \AdR;
  \item Essere comprensibile, robusta e affidabile;
  \item Presentare componenti semplici, in maniera tale da garantire modularità e riusabilità, semplificando il lavoro dello sviluppatore;  
  \item Utilizzare le risorse in maniera efficiente.
\end{itemize}


\subsubsection{Codifica}
\paragraph{Scopo}
Lo scopo del processo di codifica è l'effettiva realizzazione del prodotto software, svolto dal \textit{\PR}. Si può vedere come la trasformazione in codice dell’architettura definita dai \textit{Progettisti}, per arrivare allo sviluppo del prodotto finale.

\paragraph{Descrizione}
Il codice deve rispettare gli obiettivi di qualità definiti nel \PdQ. Nelle sezioni sottostanti saranno elencate regole e norme di carattere più generale, utilizzate da ogni linguaggio di programmazione impiegato nel progetto. 

\paragraph{Stile di codifica}

\subparagraph{Norme di buona programmazione}
Di seguito le più importanti norme guida generali per lo sviluppo del codice che il gruppo si impegna a rispettare: 
\begin{itemize}
\item Produrre codice leggibile e verificabile;
\item Strutturare la codifica in modo da rispettare il design progettato;
\item Massimizzare l'information hiding.
\end{itemize}

\subparagraph{Brevità dei metodi}
In generale ogni metodo o procedura dovrebbe essere breve e conciso, tra le 20 e 25 righe (contando un'istruzione per riga). Poiché il bisogno di scrivere un metodo più lungo può diventare necessario, si possono considerare tollerabili procedure fino ad un massimo di 35-40 righe. Nel caso in cui la soglia venga superata, ha senso considerare una suddivisione della procedura. E' fondamentale concentrarsi sullo scopo di ogni procedura, evitando singole procedure che svolgono troppi compiti.

\subparagraph{Norme di struttura per il linguaggio Python}
Molte di queste norme derivano dallo standard di codifica Python PEP 8 che il gruppo di sviluppo della parte di backend si impegna a rispettare.
\begin{itemize}
\item \textbf{Indentazione}: i blocchi di codice innestati dovranno avere un’indentazione di quattro spazi, evitando l'utilizzo di tabulazioni;
\item \textbf{Lunghezza massima}: Ogni riga di codice dovrà avere una lunghezza massima di 79 caratteri; 
\item \textbf{Import}: Ogni import vanno generalmente in linee separate (da evitare import multipli separati da virgola), e vanno raggruppati per categorie (librerie standard, librerie di terze parti, librerie specifiche dell'applicazione) separate da una linea vuota;
\item \textbf{Commenti}: i commenti al codice saranno presentati in lingua inglese. Se necessari dovranno trovarsi generalmente sopra al costrutto in questione;
\item  \textbf{Univocità dei nomi}: tutti i costrutti dovranno avere nomi univoci ed autoesplicativi, da evitare nomi eccessivamente lunghi.
\item \textbf{Operazioni logiche/matematiche}: Preferibilmente vanno spezzate portanto il simbolo dell'operazione (es. "+") nella nuova linea.
\end{itemize}

\subparagraph{Convenzioni sulla nomenclatura per il linguaggio Python}
Molte di queste norme derivano dallo standard di codifica Python PEP 8 che il gruppo di sviluppo della parte di backend si impegna a rispettare.

In generale per i nomi verrà utilizzata la nomenclatura "snake case", dove ogni parola è in minuscolo, separata da un underscore, con alcune particolarità:
\begin{itemize}
\item Nomi di variabili e metodi dovranno cominciare con la lettera minuscola;
\item Nomi di classi e file dovranno cominciare con la lettera maiuscola e rispettare la convenzione camel case, dove le parole sono unite tra di loro e l'iniziale di ogni parola è in maiuscolo;
\item Nomi di costanti dovranno essere scritti tutti in maiuscolo, separando le parole con il carattere underscore "\_" ;
\item I nomi delle varie cartelle e package dovranno essere il snake case, con le iniziali minuscole e vanno preferiti nomi brevi e composti da una singola parola.
\end{itemize}

\subparagraph{Norme di struttura per il linguaggio Javascript}
Molte delle norme derivano dallo standard di codifica Javascript Standard Style che il gruppo della parte di frontend si impegna a rispettare.

\begin{itemize}
\item \textbf{Indentazione} : i blocchi di codice innestati hanno un'identazione di due spazi, evitando l'utilizzo di tabulazioni;
\item \textbf{Import} : ogni import è in una linea separata e sono raggruppati per categoria (classi, librerie esterne, css) oppure in certi casi per utilizzo (tutti quelli che servono per una determinata operazione sono raggruppati); 
\item \textbf{Commenti} : i commenti al codice sono in lingua inglese (come accordato con l'azienda). Solitamente si trovano sopra i metodi o le variabili che descrivono;
\item \textbf{Univocità dei nomi} : tutti i costrutti hanno nomi univoci e autoesplicativi.
\end{itemize}

\subparagraph{Convenzioni sulla nomenclatura per il linguaggio Javascript}
Molte delle norme derivano dallo standard di codifica Javascript Standard Style che il gruppo della parte di frontend si impegna a rispettare.

In generale per i nomi verrà utilizzata la nomenclatura "camelCase", dove ogni parola è in minuscolo e ogni parola successiva alla prima inizia con una lettera maiuscola, con alcune particolarità:
\begin{itemize}
\item Nomi di variabili e metodi cominciano con la lettera minuscola;
\item Nomi di classe e file cominciano con la lettera maiuscola e rispettano la convenzione "camelCase", a eccezione dei file css che cominciano con una minuscola;
\item Nomi delle cartelle che raggruppano per sezione e i package sono in minuscolo e rispettano la convenzione "camelCase", a eccezione fatta delle cartelle più profonde, quelle dedicate a un singolo componente, che invece inizieranno con la lettera maiuscola. Di solito, queste cartelle, hanno lo stesso nome di uno dei file che contengono, ovvero il componente.
\end{itemize}


\paragraph{Metriche}
Per la valutazione del processo di codifica saranno adottate le seguenti metriche:
\begin{itemize}

\item \textbf{MQP02 Profondità di una gerarchia} \\
È un valore intero che definisce quanto può essere profonda la gerarchia di una classe. Nel caso una gerarchia abbia una sola classe, allora il suo valore sarà pari a 1;

\item \textbf{MQP03 Numero parametri per metodo} \\
Indica il numero intero di parametri che può avere un metodo. Un numero di parametri troppo elevato, indica che è necessario ridurre delle funzionalità associate al metodo a cui si fa riferimento. Inoltre, se si ha un numero elevato di parametri, la probabilità di avere più errori progettuali aumenta;

\item \textbf{MQP05 Percentuale requisiti obbligatori soddisfatti} \\
Indica la quantità percentuale dei requisiti obbligatori soddisfatti in rapporto al totale dei requisiti obbligatori.
La formula è:
\begin{itemize}
  \item[] \[RS = \frac{ROS}{TRO} * 100;\]
  \item RS = Percentuale requisiti obbligatori soddisfatti;
  \item ROS = Requisiti obbligatori soddisfatti;
  \item TRO = Totale requisiti 	obbligatori.
  \end{itemize}

\item \textbf{MQP06 Complessità ciclomatica}\\
La complessità ciclomatica è una metrica sviluppata da Thomas J. McCabeornisce che fornisce una misura quantitativa della complessità di un programma, essa è identificata dal numero di cammini linearmente indipendenti presenti nel grafo del flusso di controllo del programma. Un valore elevato di tale misurazione indica che il software possiede un comportamento poco predicibile, fattore che causa grandi rischi.
La formula è:
\begin{itemize}
  \item[] \[CC 	= E - N + P;\]
  \item CC = Complessità ciclomatica;
  \item E = Numero di congiunzioni tra statement (gli archi di un grafo);
  \item N = Numero di statement (nodi presenti nel grafo);
  \item P = Numero delle componenti connesse da ogni nodo (per esecuzione sequenziale P = 2 essendovi 1 predecessore e 1 successore per ogni arco).
  \end{itemize}


\item \textbf{MQP07 Numero di bug}\\
Numero di righe di codice del programma che potrebbero comportare un risultato diverso da quello previsto.

\item \textbf{MQP08 Numero di code smell}\\
Indica una serie di caratteristiche che il codice sorgente può avere e che sono generalmente riconosciute come probabili indicazioni di un difetto di programmazione.

\item \textbf{MQP09 Linee di Commento per Linee di Codice} \\
La formula è:
\begin{itemize}
  \item[] \[LCC = \frac{LDC}{LCD} * 100 ;\]
  \item LCC = Percentuale rapporto tra linee di commento e linee di codice di istruzioni;
  \item LDC = Linee di commento;
  \item LCD = Linee di codice.
  \end{itemize}


\item \textbf{MQP12 Numero di vulnerabilità}\\
Indica il numero di vulnerabilità presenti nel codice sorgente del prodotto.
\end{itemize}
Per maggiori informazioni consultare \S{}C.

\paragraph{Strumenti}
Gli strumenti che verranno adottati durante il processo di sviluppo sono:
\begin{itemize}
\item \textbf{PyCharm Community Edition}: IDE preferito per lo sviluppo in Python, per il fatto che offre uno strumento nativo di refactor automatico che impone il rispetto dello standard PEP 8.
\item \textbf{Atom}: IDE preferito per lo sviluppo in Javascript/HTML/CSS;
\item \textbf{Visual Studio Code}: IDE alternativo utilizzato dal gruppo per la stesura del codice;
\item \textbf{AWS CLI}\textsuperscript{G}: uno strumento unificato per la gestione dei servizi AWS\textsuperscript{G} via interfaccia a riga di comando.
\item \textbf{StarUML}: strumento utilizzato per la produzione dei diagrammi UML.

\end{itemize}
